<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>PostgresSourceOperations.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">source-postgres</a> &gt; <a href="index.source.html" class="el_package">io.airbyte.integrations.source.postgres</a> &gt; <span class="el_source">PostgresSourceOperations.java</span></div><h1>PostgresSourceOperations.java</h1><pre class="source lang-java linenums">/*
 * Copyright (c) 2023 Airbyte, Inc., all rights reserved.
 */

package io.airbyte.integrations.source.postgres;

import static io.airbyte.db.DataTypeUtils.TIMESTAMPTZ_FORMATTER;
import static io.airbyte.db.jdbc.JdbcConstants.INTERNAL_COLUMN_NAME;
import static io.airbyte.db.jdbc.JdbcConstants.INTERNAL_COLUMN_TYPE;
import static io.airbyte.db.jdbc.JdbcConstants.INTERNAL_COLUMN_TYPE_NAME;
import static io.airbyte.db.jdbc.JdbcConstants.INTERNAL_DECIMAL_DIGITS;
import static io.airbyte.db.jdbc.JdbcConstants.INTERNAL_SCHEMA_NAME;
import static io.airbyte.db.jdbc.JdbcConstants.INTERNAL_TABLE_NAME;
import static io.airbyte.integrations.source.postgres.PostgresType.safeGetJdbcType;

import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.databind.JsonNode;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.fasterxml.jackson.databind.node.ArrayNode;
import com.fasterxml.jackson.databind.node.BinaryNode;
import com.fasterxml.jackson.databind.node.NullNode;
import com.fasterxml.jackson.databind.node.ObjectNode;
import com.google.common.annotations.VisibleForTesting;
import io.airbyte.commons.jackson.MoreMappers;
import io.airbyte.commons.json.Jsons;
import io.airbyte.db.DataTypeUtils;
import io.airbyte.db.SourceOperations;
import io.airbyte.db.jdbc.AbstractJdbcCompatibleSourceOperations;
import io.airbyte.db.jdbc.DateTimeConverter;
import io.airbyte.protocol.models.JsonSchemaPrimitiveUtil.JsonSchemaPrimitive;
import io.airbyte.protocol.models.JsonSchemaType;
import java.math.BigDecimal;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.ResultSetMetaData;
import java.sql.SQLException;
import java.sql.Timestamp;
import java.time.LocalDate;
import java.time.LocalDateTime;
import java.time.LocalTime;
import java.time.OffsetDateTime;
import java.time.OffsetTime;
import java.time.format.DateTimeParseException;
import java.util.Arrays;
import java.util.Collections;
import java.util.HashMap;
import java.util.Map;
import org.postgresql.geometric.PGbox;
import org.postgresql.geometric.PGcircle;
import org.postgresql.geometric.PGline;
import org.postgresql.geometric.PGlseg;
import org.postgresql.geometric.PGpath;
import org.postgresql.geometric.PGpoint;
import org.postgresql.geometric.PGpolygon;
import org.postgresql.jdbc.PgResultSetMetaData;
import org.postgresql.util.PGobject;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

<span class="fc" id="L60">public class PostgresSourceOperations extends AbstractJdbcCompatibleSourceOperations&lt;PostgresType&gt;</span>
    implements SourceOperations&lt;ResultSet, PostgresType&gt; {

<span class="fc" id="L63">  private static final Logger LOGGER = LoggerFactory.getLogger(PostgresSourceOperations.class);</span>
  private static final String TIMESTAMPTZ = &quot;timestamptz&quot;;
  private static final String TIMETZ = &quot;timetz&quot;;
<span class="fc" id="L66">  private static final ObjectMapper OBJECT_MAPPER = MoreMappers.initMapper();</span>
<span class="fc" id="L67">  private static final Map&lt;Integer, PostgresType&gt; POSTGRES_TYPE_DICT = new HashMap&lt;&gt;();</span>
<span class="fc" id="L68">  private final Map&lt;String, Map&lt;String, ColumnInfo&gt;&gt; streamColumnInfo = new HashMap&lt;&gt;();</span>

  static {
<span class="fc" id="L71">    Arrays.stream(PostgresType.class.getEnumConstants()).forEach(c -&gt; POSTGRES_TYPE_DICT.put(c.type, c));</span>
<span class="fc" id="L72">  }</span>

  @Override
  public JsonNode rowToJson(final ResultSet queryContext) throws SQLException {
    // the first call communicates with the database. after that the result is cached.
<span class="fc" id="L77">    final ResultSetMetaData metadata = queryContext.getMetaData();</span>
<span class="fc" id="L78">    final int columnCount = metadata.getColumnCount();</span>
<span class="fc" id="L79">    final ObjectNode jsonNode = (ObjectNode) Jsons.jsonNode(Collections.emptyMap());</span>

<span class="fc bfc" id="L81" title="All 2 branches covered.">    for (int i = 1; i &lt;= columnCount; i++) {</span>
      // convert to java types that will convert into reasonable json.
<span class="fc" id="L83">      copyToJsonField(queryContext, i, jsonNode);</span>
    }

<span class="fc" id="L86">    return jsonNode;</span>
  }

  @Override
  public void setCursorField(final PreparedStatement preparedStatement,
                             final int parameterIndex,
                             final PostgresType cursorFieldType,
                             final String value)
      throws SQLException {
<span class="pc bpc" id="L95" title="8 of 16 branches missed.">    switch (cursorFieldType) {</span>

<span class="fc" id="L97">      case TIMESTAMP -&gt; setTimestamp(preparedStatement, parameterIndex, value);</span>
<span class="fc" id="L98">      case TIMESTAMP_WITH_TIMEZONE -&gt; setTimestampWithTimezone(preparedStatement, parameterIndex, value);</span>
<span class="fc" id="L99">      case TIME -&gt; setTime(preparedStatement, parameterIndex, value);</span>
<span class="fc" id="L100">      case TIME_WITH_TIMEZONE -&gt; setTimeWithTimezone(preparedStatement, parameterIndex, value);</span>
<span class="fc" id="L101">      case DATE -&gt; setDate(preparedStatement, parameterIndex, value);</span>
<span class="nc" id="L102">      case BIT -&gt; setBit(preparedStatement, parameterIndex, value);</span>
<span class="nc" id="L103">      case BOOLEAN -&gt; setBoolean(preparedStatement, parameterIndex, value);</span>
<span class="nc" id="L104">      case TINYINT, SMALLINT -&gt; setShortInt(preparedStatement, parameterIndex, value);</span>
<span class="fc" id="L105">      case INTEGER -&gt; setInteger(preparedStatement, parameterIndex, value);</span>
<span class="nc" id="L106">      case BIGINT -&gt; setBigInteger(preparedStatement, parameterIndex, value);</span>
<span class="nc" id="L107">      case FLOAT, DOUBLE -&gt; setDouble(preparedStatement, parameterIndex, value);</span>
<span class="nc" id="L108">      case REAL -&gt; setReal(preparedStatement, parameterIndex, value);</span>
<span class="fc" id="L109">      case NUMERIC, DECIMAL -&gt; setDecimal(preparedStatement, parameterIndex, value);</span>
<span class="fc" id="L110">      case CHAR, NCHAR, NVARCHAR, VARCHAR, LONGVARCHAR -&gt; setString(preparedStatement, parameterIndex, value);</span>
<span class="nc" id="L111">      case BINARY, BLOB -&gt; setBinary(preparedStatement, parameterIndex, value);</span>
      // since cursor are expected to be comparable, handle cursor typing strictly and error on
      // unrecognized types
<span class="nc" id="L114">      default -&gt; throw new IllegalArgumentException(String.format(&quot;%s cannot be used as a cursor.&quot;, cursorFieldType));</span>
    }
<span class="fc" id="L116">  }</span>

  private void setTimeWithTimezone(final PreparedStatement preparedStatement, final int parameterIndex, final String value) throws SQLException {
    try {
<span class="fc" id="L120">      preparedStatement.setObject(parameterIndex, OffsetTime.parse(value));</span>
<span class="nc" id="L121">    } catch (final DateTimeParseException e) {</span>
      // attempt to parse the time w/o timezone. This can be caused by schema created with a different
      // version of the connector
<span class="nc" id="L124">      preparedStatement.setObject(parameterIndex, LocalTime.parse(value));</span>
<span class="fc" id="L125">    }</span>
<span class="fc" id="L126">  }</span>

  private void setTimestampWithTimezone(final PreparedStatement preparedStatement, final int parameterIndex, final String value) throws SQLException {
    try {
<span class="fc" id="L130">      preparedStatement.setObject(parameterIndex, OffsetDateTime.parse(value));</span>
<span class="nc" id="L131">    } catch (final DateTimeParseException e) {</span>
      // attempt to parse the datetime w/o timezone. This can be caused by schema created with a different
      // version of the connector
<span class="nc" id="L134">      preparedStatement.setObject(parameterIndex, LocalDateTime.parse(value));</span>
<span class="fc" id="L135">    }</span>
<span class="fc" id="L136">  }</span>

  @Override
  protected void setTimestamp(final PreparedStatement preparedStatement, final int parameterIndex, final String value) throws SQLException {
    try {
<span class="fc" id="L141">      preparedStatement.setObject(parameterIndex, LocalDateTime.parse(value));</span>
<span class="nc" id="L142">    } catch (final DateTimeParseException e) {</span>
      // attempt to parse the datetime with timezone. This can be caused by schema created with an older
      // version of the connector
<span class="nc" id="L145">      preparedStatement.setObject(parameterIndex, OffsetDateTime.parse(value));</span>
<span class="fc" id="L146">    }</span>
<span class="fc" id="L147">  }</span>

  @Override
  protected void setDate(final PreparedStatement preparedStatement, final int parameterIndex, final String value) throws SQLException {
<span class="fc" id="L151">    preparedStatement.setObject(parameterIndex, LocalDate.parse(value));</span>
<span class="fc" id="L152">  }</span>

  @Override
  public void copyToJsonField(final ResultSet resultSet, final int colIndex, final ObjectNode json) throws SQLException {
<span class="fc" id="L156">    final PgResultSetMetaData metadata = (PgResultSetMetaData) resultSet.getMetaData();</span>
<span class="fc" id="L157">    final String columnName = metadata.getColumnName(colIndex);</span>
<span class="fc" id="L158">    final ColumnInfo columnInfo = getColumnInfo(colIndex, metadata, columnName);</span>
<span class="fc" id="L159">    final String value = resultSet.getString(colIndex);</span>
<span class="fc bfc" id="L160" title="All 2 branches covered.">    if (value == null) {</span>
<span class="fc" id="L161">      json.putNull(columnName);</span>
    } else {
<span class="pc bpc" id="L163" title="22 of 27 branches missed.">      switch (columnInfo.columnTypeName) {</span>
<span class="fc" id="L164">        case &quot;bool&quot;, &quot;boolean&quot; -&gt; putBoolean(json, columnName, resultSet, colIndex);</span>
<span class="nc" id="L165">        case &quot;bytea&quot; -&gt; json.put(columnName, value);</span>
<span class="fc" id="L166">        case TIMETZ -&gt; putTimeWithTimezone(json, columnName, resultSet, colIndex);</span>
<span class="fc" id="L167">        case TIMESTAMPTZ -&gt; putTimestampWithTimezone(json, columnName, resultSet, colIndex);</span>
<span class="nc" id="L168">        case &quot;hstore&quot; -&gt; putHstoreAsJson(json, columnName, resultSet, colIndex);</span>
<span class="nc" id="L169">        case &quot;circle&quot; -&gt; putObject(json, columnName, resultSet, colIndex, PGcircle.class);</span>
<span class="nc" id="L170">        case &quot;box&quot; -&gt; putObject(json, columnName, resultSet, colIndex, PGbox.class);</span>
<span class="fc" id="L171">        case &quot;double precision&quot;, &quot;float&quot;, &quot;float8&quot; -&gt; putDouble(json, columnName, resultSet, colIndex);</span>
<span class="nc" id="L172">        case &quot;line&quot; -&gt; putObject(json, columnName, resultSet, colIndex, PGline.class);</span>
<span class="nc" id="L173">        case &quot;lseg&quot; -&gt; putObject(json, columnName, resultSet, colIndex, PGlseg.class);</span>
<span class="nc" id="L174">        case &quot;path&quot; -&gt; putObject(json, columnName, resultSet, colIndex, PGpath.class);</span>
<span class="nc" id="L175">        case &quot;point&quot; -&gt; putObject(json, columnName, resultSet, colIndex, PGpoint.class);</span>
<span class="nc" id="L176">        case &quot;polygon&quot; -&gt; putObject(json, columnName, resultSet, colIndex, PGpolygon.class);</span>
<span class="nc" id="L177">        case &quot;_varchar&quot;, &quot;_char&quot;, &quot;_bpchar&quot;, &quot;_text&quot;, &quot;_name&quot; -&gt; putArray(json, columnName, resultSet, colIndex);</span>
<span class="nc" id="L178">        case &quot;_int2&quot;, &quot;_int4&quot;, &quot;_int8&quot;, &quot;_oid&quot; -&gt; putLongArray(json, columnName, resultSet, colIndex);</span>
        case &quot;_numeric&quot;, &quot;_decimal&quot; -&gt; {
          // If a numeric_array column precision is not 0 AND scale is 0,
          // then we know the precision and scale are purposefully chosen
<span class="nc bnc" id="L182" title="All 4 branches missed.">          if (metadata.getPrecision(colIndex) != 0 &amp;&amp; metadata.getScale(colIndex) == 0) {</span>
<span class="nc" id="L183">            putBigIntArray(json, columnName, resultSet, colIndex);</span>
          } else {
<span class="nc" id="L185">            putBigDecimalArray(json, columnName, resultSet, colIndex);</span>
          }
<span class="nc" id="L187">        }</span>
<span class="nc" id="L188">        case &quot;_money&quot; -&gt; putMoneyArray(json, columnName, resultSet, colIndex);</span>
<span class="nc" id="L189">        case &quot;_float4&quot;, &quot;_float8&quot; -&gt; putDoubleArray(json, columnName, resultSet, colIndex);</span>
<span class="nc" id="L190">        case &quot;_bool&quot; -&gt; putBooleanArray(json, columnName, resultSet, colIndex);</span>
<span class="nc" id="L191">        case &quot;_bit&quot; -&gt; putBitArray(json, columnName, resultSet, colIndex);</span>
<span class="nc" id="L192">        case &quot;_bytea&quot; -&gt; putByteaArray(json, columnName, resultSet, colIndex);</span>
<span class="nc" id="L193">        case &quot;_date&quot; -&gt; putDateArray(json, columnName, resultSet, colIndex);</span>
<span class="nc" id="L194">        case &quot;_timestamptz&quot; -&gt; putTimestampTzArray(json, columnName, resultSet, colIndex);</span>
<span class="nc" id="L195">        case &quot;_timestamp&quot; -&gt; putTimestampArray(json, columnName, resultSet, colIndex);</span>
<span class="nc" id="L196">        case &quot;_timetz&quot; -&gt; putTimeTzArray(json, columnName, resultSet, colIndex);</span>
<span class="nc" id="L197">        case &quot;_time&quot; -&gt; putTimeArray(json, columnName, resultSet, colIndex);</span>
        default -&gt; {
<span class="pc bpc" id="L199" title="6 of 14 branches missed.">          switch (columnInfo.columnType) {</span>
<span class="nc" id="L200">            case BOOLEAN -&gt; json.put(columnName, value.equalsIgnoreCase(&quot;t&quot;));</span>
<span class="nc" id="L201">            case TINYINT, SMALLINT -&gt; putShortInt(json, columnName, resultSet, colIndex);</span>
<span class="fc" id="L202">            case INTEGER -&gt; putInteger(json, columnName, resultSet, colIndex);</span>
<span class="fc" id="L203">            case BIGINT -&gt; putBigInt(json, columnName, resultSet, colIndex);</span>
<span class="nc" id="L204">            case FLOAT, DOUBLE -&gt; putDouble(json, columnName, resultSet, colIndex);</span>
<span class="nc" id="L205">            case REAL -&gt; putFloat(json, columnName, resultSet, colIndex);</span>
            case NUMERIC, DECIMAL -&gt; {
<span class="pc bpc" id="L207" title="1 of 4 branches missed.">              if (metadata.getPrecision(colIndex) != 0 &amp;&amp; metadata.getScale(colIndex) == 0) {</span>
<span class="fc" id="L208">                putBigInt(json, columnName, resultSet, colIndex);</span>
              } else {
<span class="fc" id="L210">                putBigDecimal(json, columnName, resultSet, colIndex);</span>
              }
<span class="fc" id="L212">            }</span>
            // BIT is a bit string in Postgres, e.g. '0100'
<span class="fc" id="L214">            case BIT, CHAR, VARCHAR, LONGVARCHAR -&gt; json.put(columnName, value);</span>
<span class="fc" id="L215">            case DATE -&gt; putDate(json, columnName, resultSet, colIndex);</span>
<span class="fc" id="L216">            case TIME -&gt; putTime(json, columnName, resultSet, colIndex);</span>
<span class="fc" id="L217">            case TIMESTAMP -&gt; putTimestamp(json, columnName, resultSet, colIndex);</span>
<span class="nc" id="L218">            case BLOB, BINARY, VARBINARY, LONGVARBINARY -&gt; putBinary(json, columnName, resultSet, colIndex);</span>
<span class="nc" id="L219">            case ARRAY -&gt; putArray(json, columnName, resultSet, colIndex);</span>
<span class="fc" id="L220">            default -&gt; json.put(columnName, value);</span>
          }
        }
      }
    }
<span class="fc" id="L225">  }</span>

  private void putTimeArray(final ObjectNode node, final String columnName, final ResultSet resultSet, final int colIndex) throws SQLException {
<span class="nc" id="L228">    final ArrayNode arrayNode = Jsons.arrayNode();</span>
<span class="nc" id="L229">    final ResultSet arrayResultSet = resultSet.getArray(colIndex).getResultSet();</span>
<span class="nc bnc" id="L230" title="All 2 branches missed.">    while (arrayResultSet.next()) {</span>
<span class="nc" id="L231">      final LocalTime time = getObject(arrayResultSet, 2, LocalTime.class);</span>
<span class="nc bnc" id="L232" title="All 2 branches missed.">      if (time == null) {</span>
<span class="nc" id="L233">        arrayNode.add(NullNode.getInstance());</span>
      } else {
<span class="nc" id="L235">        arrayNode.add(DateTimeConverter.convertToTime(time));</span>
      }
<span class="nc" id="L237">    }</span>
<span class="nc" id="L238">    node.set(columnName, arrayNode);</span>
<span class="nc" id="L239">  }</span>

  private void putTimeTzArray(final ObjectNode node, final String columnName, final ResultSet resultSet, final int colIndex) throws SQLException {
<span class="nc" id="L242">    final ArrayNode arrayNode = Jsons.arrayNode();</span>
<span class="nc" id="L243">    final ResultSet arrayResultSet = resultSet.getArray(colIndex).getResultSet();</span>
<span class="nc bnc" id="L244" title="All 2 branches missed.">    while (arrayResultSet.next()) {</span>
<span class="nc" id="L245">      final OffsetTime timetz = getObject(arrayResultSet, 2, OffsetTime.class);</span>
<span class="nc bnc" id="L246" title="All 2 branches missed.">      if (timetz == null) {</span>
<span class="nc" id="L247">        arrayNode.add(NullNode.getInstance());</span>
      } else {
<span class="nc" id="L249">        arrayNode.add(DateTimeConverter.convertToTimeWithTimezone(timetz));</span>
      }
<span class="nc" id="L251">    }</span>
<span class="nc" id="L252">    node.set(columnName, arrayNode);</span>
<span class="nc" id="L253">  }</span>

  private void putTimestampArray(final ObjectNode node, final String columnName, final ResultSet resultSet, final int colIndex) throws SQLException {
<span class="nc" id="L256">    final ArrayNode arrayNode = Jsons.arrayNode();</span>
<span class="nc" id="L257">    final ResultSet arrayResultSet = resultSet.getArray(colIndex).getResultSet();</span>
<span class="nc bnc" id="L258" title="All 2 branches missed.">    while (arrayResultSet.next()) {</span>
<span class="nc" id="L259">      final Timestamp timestamp = arrayResultSet.getTimestamp(2);</span>
<span class="nc bnc" id="L260" title="All 2 branches missed.">      if (timestamp == null) {</span>
<span class="nc" id="L261">        arrayNode.add(NullNode.getInstance());</span>
      } else {
<span class="nc" id="L263">        arrayNode.add(DateTimeConverter.convertToTimestamp(timestamp));</span>
      }
<span class="nc" id="L265">    }</span>
<span class="nc" id="L266">    node.set(columnName, arrayNode);</span>
<span class="nc" id="L267">  }</span>

  private void putTimestampTzArray(final ObjectNode node, final String columnName, final ResultSet resultSet, final int colIndex)
      throws SQLException {
<span class="nc" id="L271">    final ArrayNode arrayNode = Jsons.arrayNode();</span>
<span class="nc" id="L272">    final ResultSet arrayResultSet = resultSet.getArray(colIndex).getResultSet();</span>
<span class="nc bnc" id="L273" title="All 2 branches missed.">    while (arrayResultSet.next()) {</span>
<span class="nc" id="L274">      final OffsetDateTime timestamptz = getObject(arrayResultSet, 2, OffsetDateTime.class);</span>
<span class="nc bnc" id="L275" title="All 2 branches missed.">      if (timestamptz == null) {</span>
<span class="nc" id="L276">        arrayNode.add(NullNode.getInstance());</span>
      } else {
<span class="nc" id="L278">        final LocalDate localDate = timestamptz.toLocalDate();</span>
<span class="nc" id="L279">        arrayNode.add(resolveEra(localDate, timestamptz.format(TIMESTAMPTZ_FORMATTER)));</span>
      }
<span class="nc" id="L281">    }</span>
<span class="nc" id="L282">    node.set(columnName, arrayNode);</span>
<span class="nc" id="L283">  }</span>

  private void putDateArray(final ObjectNode node, final String columnName, final ResultSet resultSet, final int colIndex) throws SQLException {
<span class="nc" id="L286">    final ArrayNode arrayNode = Jsons.arrayNode();</span>
<span class="nc" id="L287">    final ResultSet arrayResultSet = resultSet.getArray(colIndex).getResultSet();</span>
<span class="nc bnc" id="L288" title="All 2 branches missed.">    while (arrayResultSet.next()) {</span>
<span class="nc" id="L289">      final LocalDate date = getObject(arrayResultSet, 2, LocalDate.class);</span>
<span class="nc bnc" id="L290" title="All 2 branches missed.">      if (date == null) {</span>
<span class="nc" id="L291">        arrayNode.add(NullNode.getInstance());</span>
      } else {
<span class="nc" id="L293">        arrayNode.add(DateTimeConverter.convertToDate(date));</span>
      }
<span class="nc" id="L295">    }</span>
<span class="nc" id="L296">    node.set(columnName, arrayNode);</span>
<span class="nc" id="L297">  }</span>

  private void putByteaArray(final ObjectNode node, final String columnName, final ResultSet resultSet, final int colIndex) throws SQLException {
<span class="nc" id="L300">    final ArrayNode arrayNode = Jsons.arrayNode();</span>
<span class="nc" id="L301">    final ResultSet arrayResultSet = resultSet.getArray(colIndex).getResultSet();</span>
<span class="nc bnc" id="L302" title="All 2 branches missed.">    while (arrayResultSet.next()) {</span>
<span class="nc" id="L303">      arrayNode.add(new BinaryNode(arrayResultSet.getBytes(2)));</span>
    }
<span class="nc" id="L305">    node.set(columnName, arrayNode);</span>
<span class="nc" id="L306">  }</span>

  private void putBitArray(final ObjectNode node, final String columnName, final ResultSet resultSet, final int colIndex) throws SQLException {
<span class="nc" id="L309">    final ArrayNode arrayNode = Jsons.arrayNode();</span>
<span class="nc" id="L310">    final ResultSet arrayResultSet = resultSet.getArray(colIndex).getResultSet();</span>
<span class="nc bnc" id="L311" title="All 2 branches missed.">    while (arrayResultSet.next()) {</span>
<span class="nc" id="L312">      final String res = arrayResultSet.getString(2);</span>
<span class="nc bnc" id="L313" title="All 2 branches missed.">      if (res == null) {</span>
<span class="nc" id="L314">        arrayNode.add(NullNode.getInstance());</span>
      } else {
<span class="nc" id="L316">        arrayNode.add(&quot;1&quot;.equals(res));</span>
      }
<span class="nc" id="L318">    }</span>
<span class="nc" id="L319">    node.set(columnName, arrayNode);</span>
<span class="nc" id="L320">  }</span>

  private void putBooleanArray(final ObjectNode node, final String columnName, final ResultSet resultSet, final int colIndex) throws SQLException {
<span class="nc" id="L323">    final ArrayNode arrayNode = Jsons.arrayNode();</span>
<span class="nc" id="L324">    final ResultSet arrayResultSet = resultSet.getArray(colIndex).getResultSet();</span>
<span class="nc bnc" id="L325" title="All 2 branches missed.">    while (arrayResultSet.next()) {</span>
<span class="nc" id="L326">      final String res = arrayResultSet.getString(2);</span>
<span class="nc bnc" id="L327" title="All 2 branches missed.">      if (res == null) {</span>
<span class="nc" id="L328">        arrayNode.add(NullNode.getInstance());</span>
      } else {
<span class="nc" id="L330">        arrayNode.add(&quot;t&quot;.equalsIgnoreCase(res));</span>
      }
<span class="nc" id="L332">    }</span>
<span class="nc" id="L333">    node.set(columnName, arrayNode);</span>
<span class="nc" id="L334">  }</span>

  private void putBigDecimalArray(final ObjectNode node, final String columnName, final ResultSet resultSet, final int colIndex) throws SQLException {
<span class="nc" id="L337">    final ArrayNode arrayNode = Jsons.arrayNode();</span>
<span class="nc" id="L338">    final ResultSet arrayResultSet = resultSet.getArray(colIndex).getResultSet();</span>
<span class="nc bnc" id="L339" title="All 2 branches missed.">    while (arrayResultSet.next()) {</span>
<span class="nc" id="L340">      final BigDecimal bigDecimal = DataTypeUtils.returnNullIfInvalid(() -&gt; arrayResultSet.getBigDecimal(2));</span>
<span class="nc bnc" id="L341" title="All 2 branches missed.">      if (bigDecimal != null) {</span>
<span class="nc" id="L342">        arrayNode.add(bigDecimal);</span>
      } else {
<span class="nc" id="L344">        arrayNode.add((BigDecimal) null);</span>
      }
<span class="nc" id="L346">    }</span>
<span class="nc" id="L347">    node.set(columnName, arrayNode);</span>
<span class="nc" id="L348">  }</span>

  private void putBigIntArray(final ObjectNode node, final String columnName, final ResultSet resultSet, final int colIndex) throws SQLException {
<span class="nc" id="L351">    final ArrayNode arrayNode = Jsons.arrayNode();</span>
<span class="nc" id="L352">    final ResultSet arrayResultSet = resultSet.getArray(colIndex).getResultSet();</span>
<span class="nc bnc" id="L353" title="All 2 branches missed.">    while (arrayResultSet.next()) {</span>
<span class="nc" id="L354">      final long value = DataTypeUtils.returnNullIfInvalid(() -&gt; arrayResultSet.getLong(2));</span>
<span class="nc" id="L355">      arrayNode.add(value);</span>
<span class="nc" id="L356">    }</span>
<span class="nc" id="L357">    node.set(columnName, arrayNode);</span>
<span class="nc" id="L358">  }</span>


  private void putDoubleArray(final ObjectNode node, final String columnName, final ResultSet resultSet, final int colIndex) throws SQLException {
<span class="nc" id="L362">    final ArrayNode arrayNode = Jsons.arrayNode();</span>
<span class="nc" id="L363">    final ResultSet arrayResultSet = resultSet.getArray(colIndex).getResultSet();</span>
<span class="nc bnc" id="L364" title="All 2 branches missed.">    while (arrayResultSet.next()) {</span>
<span class="nc" id="L365">      arrayNode.add(DataTypeUtils.returnNullIfInvalid(() -&gt; arrayResultSet.getDouble(colIndex), Double::isFinite));</span>
    }
<span class="nc" id="L367">    node.set(columnName, arrayNode);</span>
<span class="nc" id="L368">  }</span>

  private void putMoneyArray(final ObjectNode node, final String columnName, final ResultSet resultSet, final int colIndex) throws SQLException {
<span class="nc" id="L371">    final ArrayNode arrayNode = Jsons.arrayNode();</span>
<span class="nc" id="L372">    final ResultSet arrayResultSet = resultSet.getArray(colIndex).getResultSet();</span>
<span class="nc bnc" id="L373" title="All 2 branches missed.">    while (arrayResultSet.next()) {</span>
<span class="nc" id="L374">      final String moneyValue = parseMoneyValue(arrayResultSet.getString(colIndex));</span>
<span class="nc" id="L375">      arrayNode.add(DataTypeUtils.returnNullIfInvalid(() -&gt; DataTypeUtils.returnNullIfInvalid(() -&gt; Double.valueOf(moneyValue), Double::isFinite)));</span>
<span class="nc" id="L376">    }</span>
<span class="nc" id="L377">    node.set(columnName, arrayNode);</span>
<span class="nc" id="L378">  }</span>

  private void putLongArray(final ObjectNode node, final String columnName, final ResultSet resultSet, final int colIndex) throws SQLException {
<span class="nc" id="L381">    final ArrayNode arrayNode = Jsons.arrayNode();</span>
<span class="nc" id="L382">    final ResultSet arrayResultSet = resultSet.getArray(colIndex).getResultSet();</span>
<span class="nc bnc" id="L383" title="All 2 branches missed.">    while (arrayResultSet.next()) {</span>
<span class="nc" id="L384">      arrayNode.add(arrayResultSet.getLong(2));</span>
    }
<span class="nc" id="L386">    node.set(columnName, arrayNode);</span>
<span class="nc" id="L387">  }</span>

  @Override
  protected void putTimestamp(final ObjectNode node, final String columnName, final ResultSet resultSet, final int index) throws SQLException {
<span class="fc" id="L391">    node.put(columnName, DateTimeConverter.convertToTimestamp(resultSet.getTimestamp(index)));</span>
<span class="fc" id="L392">  }</span>

  @Override
  public PostgresType getDatabaseFieldType(final JsonNode field) {
    try {
<span class="fc" id="L397">      final String typeName = field.get(INTERNAL_COLUMN_TYPE_NAME).asText().toLowerCase();</span>
      // Postgres boolean is mapped to JDBCType.BIT, but should be BOOLEAN
<span class="pc bpc" id="L399" title="23 of 27 branches missed.">      return switch (typeName) {</span>
<span class="nc" id="L400">        case &quot;_bit&quot; -&gt; PostgresType.BIT_ARRAY;</span>
<span class="nc" id="L401">        case &quot;_bool&quot; -&gt; PostgresType.BOOL_ARRAY;</span>
<span class="nc" id="L402">        case &quot;_name&quot; -&gt; PostgresType.NAME_ARRAY;</span>
<span class="nc" id="L403">        case &quot;_varchar&quot; -&gt; PostgresType.VARCHAR_ARRAY;</span>
<span class="nc" id="L404">        case &quot;_char&quot; -&gt; PostgresType.CHAR_ARRAY;</span>
<span class="nc" id="L405">        case &quot;_bpchar&quot; -&gt; PostgresType.BPCHAR_ARRAY;</span>
<span class="nc" id="L406">        case &quot;_text&quot; -&gt; PostgresType.TEXT_ARRAY;</span>
<span class="nc" id="L407">        case &quot;_int4&quot; -&gt; PostgresType.INT4_ARRAY;</span>
<span class="nc" id="L408">        case &quot;_int2&quot; -&gt; PostgresType.INT2_ARRAY;</span>
<span class="nc" id="L409">        case &quot;_int8&quot; -&gt; PostgresType.INT8_ARRAY;</span>
<span class="nc" id="L410">        case &quot;_money&quot; -&gt; PostgresType.MONEY_ARRAY;</span>
<span class="nc" id="L411">        case &quot;_oid&quot; -&gt; PostgresType.OID_ARRAY;</span>
<span class="nc" id="L412">        case &quot;_numeric&quot; -&gt; PostgresType.NUMERIC_ARRAY;</span>
<span class="nc" id="L413">        case &quot;_float4&quot; -&gt; PostgresType.FLOAT4_ARRAY;</span>
<span class="nc" id="L414">        case &quot;_float8&quot; -&gt; PostgresType.FLOAT8_ARRAY;</span>
<span class="nc" id="L415">        case &quot;_timestamptz&quot; -&gt; PostgresType.TIMESTAMPTZ_ARRAY;</span>
<span class="nc" id="L416">        case &quot;_timestamp&quot; -&gt; PostgresType.TIMESTAMP_ARRAY;</span>
<span class="nc" id="L417">        case &quot;_timetz&quot; -&gt; PostgresType.TIMETZ_ARRAY;</span>
<span class="nc" id="L418">        case &quot;_time&quot; -&gt; PostgresType.TIME_ARRAY;</span>
<span class="nc" id="L419">        case &quot;_date&quot; -&gt; PostgresType.DATE_ARRAY;</span>
<span class="nc" id="L420">        case &quot;_bytea&quot; -&gt; PostgresType.BYTEA_ARRAY;</span>
<span class="nc" id="L421">        case &quot;bool&quot;, &quot;boolean&quot; -&gt; PostgresType.BOOLEAN;</span>
        // BYTEA is variable length binary string with hex output format by default (e.g. &quot;\x6b707a&quot;).
        // It should not be converted to base64 binary string. So it is represented as JDBC VARCHAR.
        // https://www.postgresql.org/docs/14/datatype-binary.html
<span class="nc" id="L425">        case &quot;bytea&quot; -&gt; PostgresType.VARCHAR;</span>
        case &quot;numeric&quot;, &quot;decimal&quot; -&gt; {
<span class="pc bpc" id="L427" title="2 of 4 branches missed.">          if (field.get(INTERNAL_DECIMAL_DIGITS) != null &amp;&amp; field.get(INTERNAL_DECIMAL_DIGITS).asInt() == 0) {</span>
<span class="nc" id="L428">            yield PostgresType.BIGINT;</span>
          } else {
<span class="fc" id="L430">            yield PostgresType.valueOf(field.get(INTERNAL_COLUMN_TYPE).asInt(), POSTGRES_TYPE_DICT);</span>
          }
        }
<span class="fc" id="L433">        case TIMESTAMPTZ -&gt; PostgresType.TIMESTAMP_WITH_TIMEZONE;</span>
<span class="fc" id="L434">        case TIMETZ -&gt; PostgresType.TIME_WITH_TIMEZONE;</span>
<span class="fc" id="L435">        default -&gt; PostgresType.valueOf(field.get(INTERNAL_COLUMN_TYPE).asInt(), POSTGRES_TYPE_DICT);</span>
      };
<span class="nc" id="L437">    } catch (final IllegalArgumentException ex) {</span>
<span class="nc" id="L438">      LOGGER.warn(String.format(&quot;Could not convert column: %s from table: %s.%s with type: %s. Casting to VARCHAR.&quot;,</span>
<span class="nc" id="L439">          field.get(INTERNAL_COLUMN_NAME),</span>
<span class="nc" id="L440">          field.get(INTERNAL_SCHEMA_NAME),</span>
<span class="nc" id="L441">          field.get(INTERNAL_TABLE_NAME),</span>
<span class="nc" id="L442">          field.get(INTERNAL_COLUMN_TYPE)));</span>
<span class="nc" id="L443">      return PostgresType.VARCHAR;</span>
    }
  }

  @Override
  public JsonSchemaType getAirbyteType(final PostgresType jdbcType) {
<span class="pc bpc" id="L449" title="25 of 32 branches missed.">    return switch (jdbcType) {</span>
<span class="nc" id="L450">      case BOOLEAN -&gt; JsonSchemaType.BOOLEAN;</span>
<span class="fc" id="L451">      case TINYINT, SMALLINT, INTEGER, BIGINT -&gt; JsonSchemaType.INTEGER;</span>
<span class="fc" id="L452">      case FLOAT, DOUBLE, REAL, NUMERIC, DECIMAL -&gt; JsonSchemaType.NUMBER;</span>
<span class="nc" id="L453">      case BLOB, BINARY, VARBINARY, LONGVARBINARY -&gt; JsonSchemaType.STRING_BASE_64;</span>
<span class="nc" id="L454">      case ARRAY -&gt; JsonSchemaType.ARRAY;</span>
<span class="nc" id="L455">      case BIT_ARRAY -&gt; JsonSchemaType.builder(JsonSchemaPrimitive.ARRAY)</span>
<span class="nc" id="L456">          .withItems(JsonSchemaType.builder(JsonSchemaPrimitive.BOOLEAN)</span>
<span class="nc" id="L457">              .build())</span>
<span class="nc" id="L458">          .build();</span>
<span class="nc" id="L459">      case BOOL_ARRAY -&gt; JsonSchemaType.builder(JsonSchemaPrimitive.ARRAY)</span>
<span class="nc" id="L460">          .withItems(JsonSchemaType.builder(JsonSchemaPrimitive.BOOLEAN)</span>
<span class="nc" id="L461">              .build())</span>
<span class="nc" id="L462">          .build();</span>
<span class="nc" id="L463">      case BYTEA_ARRAY -&gt; JsonSchemaType.builder(JsonSchemaPrimitive.ARRAY)</span>
<span class="nc" id="L464">          .withItems(JsonSchemaType.builder(JsonSchemaPrimitive.STRING)</span>
<span class="nc" id="L465">              .build())</span>
<span class="nc" id="L466">          .build();</span>
<span class="nc" id="L467">      case NAME_ARRAY -&gt; JsonSchemaType.builder(JsonSchemaPrimitive.ARRAY)</span>
<span class="nc" id="L468">          .withItems(JsonSchemaType.builder(JsonSchemaPrimitive.STRING)</span>
<span class="nc" id="L469">              .build())</span>
<span class="nc" id="L470">          .build();</span>
<span class="nc" id="L471">      case VARCHAR_ARRAY -&gt; JsonSchemaType.builder(JsonSchemaPrimitive.ARRAY)</span>
<span class="nc" id="L472">          .withItems(JsonSchemaType.builder(JsonSchemaPrimitive.STRING)</span>
<span class="nc" id="L473">              .build())</span>
<span class="nc" id="L474">          .build();</span>
<span class="nc" id="L475">      case CHAR_ARRAY -&gt; JsonSchemaType.builder(JsonSchemaPrimitive.ARRAY)</span>
<span class="nc" id="L476">          .withItems(JsonSchemaType.builder(JsonSchemaPrimitive.STRING)</span>
<span class="nc" id="L477">              .build())</span>
<span class="nc" id="L478">          .build();</span>
<span class="nc" id="L479">      case BPCHAR_ARRAY -&gt; JsonSchemaType.builder(JsonSchemaPrimitive.ARRAY)</span>
<span class="nc" id="L480">          .withItems(JsonSchemaType.builder(JsonSchemaPrimitive.STRING)</span>
<span class="nc" id="L481">              .build())</span>
<span class="nc" id="L482">          .build();</span>
<span class="nc" id="L483">      case TEXT_ARRAY -&gt; JsonSchemaType.builder(JsonSchemaPrimitive.ARRAY)</span>
<span class="nc" id="L484">          .withItems(JsonSchemaType.builder(JsonSchemaPrimitive.STRING)</span>
<span class="nc" id="L485">              .build())</span>
<span class="nc" id="L486">          .build();</span>
<span class="nc" id="L487">      case INT4_ARRAY -&gt; JsonSchemaType.builder(JsonSchemaPrimitive.ARRAY)</span>
<span class="nc" id="L488">          .withItems(JsonSchemaType.INTEGER)</span>
<span class="nc" id="L489">          .build();</span>
<span class="nc" id="L490">      case INT2_ARRAY -&gt; JsonSchemaType.builder(JsonSchemaPrimitive.ARRAY)</span>
<span class="nc" id="L491">          .withItems(JsonSchemaType.INTEGER)</span>
<span class="nc" id="L492">          .build();</span>
<span class="nc" id="L493">      case INT8_ARRAY -&gt; JsonSchemaType.builder(JsonSchemaPrimitive.ARRAY)</span>
<span class="nc" id="L494">          .withItems(JsonSchemaType.INTEGER)</span>
<span class="nc" id="L495">          .build();</span>
<span class="nc" id="L496">      case MONEY_ARRAY -&gt; JsonSchemaType.builder(JsonSchemaPrimitive.ARRAY)</span>
<span class="nc" id="L497">          .withItems(JsonSchemaType.builder(JsonSchemaPrimitive.NUMBER)</span>
<span class="nc" id="L498">              .build())</span>
<span class="nc" id="L499">          .build();</span>
<span class="nc" id="L500">      case OID_ARRAY -&gt; JsonSchemaType.builder(JsonSchemaPrimitive.ARRAY)</span>
<span class="nc" id="L501">          .withItems(JsonSchemaType.builder(JsonSchemaPrimitive.NUMBER)</span>
<span class="nc" id="L502">              .build())</span>
<span class="nc" id="L503">          .build();</span>
<span class="nc" id="L504">      case NUMERIC_ARRAY -&gt; JsonSchemaType.builder(JsonSchemaPrimitive.ARRAY)</span>
<span class="nc" id="L505">          .withItems(JsonSchemaType.builder(JsonSchemaPrimitive.NUMBER)</span>
<span class="nc" id="L506">              .build())</span>
<span class="nc" id="L507">          .build();</span>
<span class="nc" id="L508">      case FLOAT4_ARRAY -&gt; JsonSchemaType.builder(JsonSchemaPrimitive.ARRAY)</span>
<span class="nc" id="L509">          .withItems(JsonSchemaType.builder(JsonSchemaPrimitive.NUMBER)</span>
<span class="nc" id="L510">              .build())</span>
<span class="nc" id="L511">          .build();</span>
<span class="nc" id="L512">      case FLOAT8_ARRAY -&gt; JsonSchemaType.builder(JsonSchemaPrimitive.ARRAY)</span>
<span class="nc" id="L513">          .withItems(JsonSchemaType.builder(JsonSchemaPrimitive.NUMBER)</span>
<span class="nc" id="L514">              .build())</span>
<span class="nc" id="L515">          .build();</span>
<span class="nc" id="L516">      case TIMESTAMPTZ_ARRAY -&gt; JsonSchemaType.builder(JsonSchemaPrimitive.ARRAY)</span>
<span class="nc" id="L517">          .withItems(JsonSchemaType.STRING_TIMESTAMP_WITH_TIMEZONE)</span>
<span class="nc" id="L518">          .build();</span>
<span class="nc" id="L519">      case TIMESTAMP_ARRAY -&gt; JsonSchemaType.builder(JsonSchemaPrimitive.ARRAY)</span>
<span class="nc" id="L520">          .withItems(JsonSchemaType.STRING_TIMESTAMP_WITHOUT_TIMEZONE)</span>
<span class="nc" id="L521">          .build();</span>
<span class="nc" id="L522">      case TIMETZ_ARRAY -&gt; JsonSchemaType.builder(JsonSchemaPrimitive.ARRAY)</span>
<span class="nc" id="L523">          .withItems(JsonSchemaType.STRING_TIME_WITH_TIMEZONE)</span>
<span class="nc" id="L524">          .build();</span>
<span class="nc" id="L525">      case TIME_ARRAY -&gt; JsonSchemaType.builder(JsonSchemaPrimitive.ARRAY)</span>
<span class="nc" id="L526">          .withItems(JsonSchemaType.STRING_TIME_WITHOUT_TIMEZONE)</span>
<span class="nc" id="L527">          .build();</span>
<span class="nc" id="L528">      case DATE_ARRAY -&gt; JsonSchemaType.builder(JsonSchemaPrimitive.ARRAY)</span>
<span class="nc" id="L529">          .withItems(JsonSchemaType.STRING_DATE)</span>
<span class="nc" id="L530">          .build();</span>

<span class="fc" id="L532">      case DATE -&gt; JsonSchemaType.STRING_DATE;</span>
<span class="nc" id="L533">      case TIME -&gt; JsonSchemaType.STRING_TIME_WITHOUT_TIMEZONE;</span>
<span class="fc" id="L534">      case TIME_WITH_TIMEZONE -&gt; JsonSchemaType.STRING_TIME_WITH_TIMEZONE;</span>
<span class="fc" id="L535">      case TIMESTAMP -&gt; JsonSchemaType.STRING_TIMESTAMP_WITHOUT_TIMEZONE;</span>
<span class="fc" id="L536">      case TIMESTAMP_WITH_TIMEZONE -&gt; JsonSchemaType.STRING_TIMESTAMP_WITH_TIMEZONE;</span>
<span class="fc" id="L537">      default -&gt; JsonSchemaType.STRING;</span>
    };
  }

  @Override
  protected void putBoolean(final ObjectNode node, final String columnName, final ResultSet resultSet, final int index) throws SQLException {
<span class="fc" id="L543">    node.put(columnName, resultSet.getString(index).equalsIgnoreCase(&quot;t&quot;));</span>
<span class="fc" id="L544">  }</span>

  protected &lt;T extends PGobject&gt; void putObject(final ObjectNode node,
                                                final String columnName,
                                                final ResultSet resultSet,
                                                final int index,
                                                final Class&lt;T&gt; clazz)
      throws SQLException {
<span class="nc" id="L552">    final T object = getObject(resultSet, index, clazz);</span>
<span class="nc" id="L553">    node.put(columnName, object.getValue());</span>
<span class="nc" id="L554">  }</span>

  @Override
  protected void putBigDecimal(final ObjectNode node, final String columnName, final ResultSet resultSet, final int index) {
<span class="fc" id="L558">    final BigDecimal bigDecimal = DataTypeUtils.returnNullIfInvalid(() -&gt; resultSet.getBigDecimal(index));</span>
<span class="fc bfc" id="L559" title="All 2 branches covered.">    if (bigDecimal != null) {</span>
<span class="fc" id="L560">      node.put(columnName, bigDecimal);</span>
    } else {
      // Special values (Infinity, -Infinity, and NaN) is default to null for now.
      // https://github.com/airbytehq/airbyte/issues/8902
<span class="fc" id="L564">      node.put(columnName, (BigDecimal) null);</span>
    }
<span class="fc" id="L566">  }</span>

  @Override
  protected void putDouble(final ObjectNode node, final String columnName, final ResultSet resultSet, final int index) throws SQLException {
<span class="pc bpc" id="L570" title="1 of 2 branches missed.">    if (resultSet.getMetaData().getColumnTypeName(index).equals(&quot;money&quot;)) {</span>
<span class="nc" id="L571">      putMoney(node, columnName, resultSet, index);</span>
    } else {
<span class="fc" id="L573">      super.putDouble(node, columnName, resultSet, index);</span>
    }
<span class="fc" id="L575">  }</span>

  private void putMoney(final ObjectNode node, final String columnName, final ResultSet resultSet, final int index) throws SQLException {
<span class="nc" id="L578">    final String moneyValue = parseMoneyValue(resultSet.getString(index));</span>
<span class="nc" id="L579">    node.put(columnName, DataTypeUtils.returnNullIfInvalid(() -&gt; Double.valueOf(moneyValue), Double::isFinite));</span>
<span class="nc" id="L580">  }</span>

  private void putHstoreAsJson(final ObjectNode node, final String columnName, final ResultSet resultSet, final int index)
      throws SQLException {
<span class="nc" id="L584">    final var data = resultSet.getObject(index);</span>
    try {
<span class="nc" id="L586">      node.put(columnName, OBJECT_MAPPER.writeValueAsString(data));</span>
<span class="nc" id="L587">    } catch (final JsonProcessingException e) {</span>
<span class="nc" id="L588">      throw new RuntimeException(&quot;Could not parse 'hstore' value:&quot; + e);</span>
<span class="nc" id="L589">    }</span>
<span class="nc" id="L590">  }</span>

  /**
   * @return monetary value in numbers without the currency symbol or thousands separators.
   */
  @VisibleForTesting
  static String parseMoneyValue(final String moneyString) {
<span class="fc" id="L597">    return moneyString.replaceAll(&quot;[^\\d.-]&quot;, &quot;&quot;);</span>
  }

  @Override
  public boolean isCursorType(final PostgresType type) {
<span class="fc" id="L602">    return PostgresUtils.ALLOWED_CURSOR_TYPES.contains(type);</span>
  }

  private ColumnInfo getColumnInfo(final int colIndex, final PgResultSetMetaData metadata, final String columnName) throws SQLException {
<span class="fc" id="L606">    final String tableName = metadata.getBaseTableName(colIndex);</span>
<span class="fc" id="L607">    final String schemaName = metadata.getBaseSchemaName(colIndex);</span>
<span class="fc" id="L608">    final String key = schemaName + tableName;</span>
<span class="fc bfc" id="L609" title="All 2 branches covered.">    if (!streamColumnInfo.containsKey(key)) {</span>
<span class="fc" id="L610">      streamColumnInfo.clear();</span>
<span class="fc" id="L611">      streamColumnInfo.put(key, new HashMap&lt;&gt;(metadata.getColumnCount()));</span>
    }

<span class="fc" id="L614">    final Map&lt;String, ColumnInfo&gt; stringColumnInfoMap = streamColumnInfo.get(key);</span>
<span class="fc bfc" id="L615" title="All 2 branches covered.">    if (stringColumnInfoMap.containsKey(columnName)) {</span>
<span class="fc" id="L616">      return stringColumnInfoMap.get(columnName);</span>
    } else {
<span class="fc" id="L618">      final PostgresType columnType = safeGetJdbcType(metadata.getColumnType(colIndex), POSTGRES_TYPE_DICT);</span>
<span class="fc" id="L619">      final ColumnInfo columnInfo = new ColumnInfo(metadata.getColumnTypeName(colIndex).toLowerCase(), columnType);</span>
<span class="fc" id="L620">      stringColumnInfoMap.put(columnName, columnInfo);</span>
<span class="fc" id="L621">      return columnInfo;</span>
    }
  }

  private static class ColumnInfo {

    public String columnTypeName;
    public PostgresType columnType;

<span class="fc" id="L630">    public ColumnInfo(final String columnTypeName, final PostgresType columnType) {</span>
<span class="fc" id="L631">      this.columnTypeName = columnTypeName;</span>
<span class="fc" id="L632">      this.columnType = columnType;</span>
<span class="fc" id="L633">    }</span>

  }

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.8.202204050719</span></div></body></html>